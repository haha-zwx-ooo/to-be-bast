(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{323:function(_,v,l){"use strict";l.r(v);var i=l(14),t=Object(i.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[_._v("#")]),_._v(" 设计模式")]),_._v(" "),v("p",[_._v("网上很多解释设计模式的,我的理解就是,以面向对象编程为基础,适应软件需求的多变性,增长性和可维护性的经验积累\n就是设计模式.是众多程序员总结的一套方法论.")]),_._v(" "),v("p",[_._v("说到面向对象为基础那么以下几步必不可少:")]),_._v(" "),v("ul",[v("li",[_._v("抽象(接口,抽象类,类)")]),_._v(" "),v("li",[_._v("组合(类与类之间的聚合关系)")]),_._v(" "),v("li",[_._v("方法(对象调用过程)")])]),_._v(" "),v("p",[_._v("说白了就是,上来第一步,一定要抽象,而不是面向过程直接写方法编程,抽象的目的是为了解耦,不必太离散,但是绝对不能\n过度耦合,抽象完成之后,第二步就是封装,多个对象组合,第三步就是对象方法调用.")]),_._v(" "),v("p",[_._v("上述的三步同样使用于系统架构, 分-合-用 拆分,集成,调用;")]),_._v(" "),v("h2",{attrs:{id:"面向对象设计原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计原则"}},[_._v("#")]),_._v(" 面向对象设计原则")]),_._v(" "),v("ol",[v("li",[_._v("单一职责（Single Responsibility Principle）")])]),_._v(" "),v("blockquote",[v("p",[_._v("这个原则顾名就可以思义，就是一个类应该只负责一个职责，术语叫：仅有一个引起其变化的原因。")])]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[_._v("开闭原则（Open Close Principle）")])]),_._v(" "),v("blockquote",[v("p",[_._v("一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。")])]),_._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[_._v("里氏替换原则（Liskov Substitution Principle）")])]),_._v(" "),v("blockquote",[v("p",[_._v("所有引用基类（父类）的地方必须能透明地使用其子类的对象。")])]),_._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[_._v("依赖倒置原则（Dependence Inversion Principle）")])]),_._v(" "),v("blockquote",[v("p",[_._v("抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n关键点：")]),_._v(" "),v("ul",[v("li",[_._v("高层模块不应该依赖低层模块，两者都应该依赖其抽象")]),_._v(" "),v("li",[_._v("抽象不应该依赖细节")]),_._v(" "),v("li",[_._v("细节应该依赖抽象")])])]),_._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[_._v("接口隔离原则（Interface Segregation Principle）")])]),_._v(" "),v("blockquote",[v("p",[_._v("使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。")])]),_._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[_._v("迪米特原则（Law of Demeter ）")])]),_._v(" "),v("blockquote",[v("p",[_._v("一个软件实体应当尽可能少地与其他实体发生相互作用。")])]),_._v(" "),v("p",[_._v("所以,设计模式按照面向对象语法和原则,主要有23种类型,从场景上看分为三种:")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("创建型设计模式")]),_._v(" "),v("ol",[v("li",[_._v("抽象工厂")]),_._v(" "),v("li",[_._v("建造者")]),_._v(" "),v("li",[_._v("工厂方法")]),_._v(" "),v("li",[_._v("原型")]),_._v(" "),v("li",[_._v("单例")])])]),_._v(" "),v("li",[v("p",[_._v("结构型设计模式")]),_._v(" "),v("ol",[v("li",[_._v("适配器")]),_._v(" "),v("li",[_._v("桥接")]),_._v(" "),v("li",[_._v("组合")]),_._v(" "),v("li",[_._v("装饰")]),_._v(" "),v("li",[_._v("外观")]),_._v(" "),v("li",[_._v("享元")]),_._v(" "),v("li",[_._v("代理")])])]),_._v(" "),v("li",[v("p",[_._v("行为型设计模式")]),_._v(" "),v("ol",[v("li",[_._v("责任链")]),_._v(" "),v("li",[_._v("命令")]),_._v(" "),v("li",[_._v("解释器")]),_._v(" "),v("li",[_._v("迭代器")]),_._v(" "),v("li",[_._v("中介者")]),_._v(" "),v("li",[_._v("备忘录")]),_._v(" "),v("li",[_._v("观察者")]),_._v(" "),v("li",[_._v("状态")]),_._v(" "),v("li",[_._v("策略")]),_._v(" "),v("li",[_._v("模板方法")]),_._v(" "),v("li",[_._v("访问者")])])])]),_._v(" "),v("p",[_._v("后面会对每个设计模式进行单独讲解,需要注意的是任何一种设计模式并不是独立的,经常性是多种设计模式组合使用,所以\n不要对设计模式分类产生歧义,只是一个方法论,多元化组合才是实践.")]),_._v(" "),v("p",[_._v("在了解具体设计模式之前,必须要知道 uml 类图和时序图 用来表示类关系和调用关系")]),_._v(" "),v("p",[v("img",{attrs:{src:"/to-be-bast/images/uml_class_struct.jpg",alt:"uml_class_struct"}})]),_._v(" "),v("ul",[v("li",[_._v("车的类图结构为<"),v("abstract",[_._v(">，表示车是一个抽象类；")])],1),_._v(" "),v("li",[_._v("它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；")]),_._v(" "),v("li",[_._v("小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；")]),_._v(" "),v("li",[_._v("小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；")]),_._v(" "),v("li",[_._v("学生与班级之间是聚合关系，使用带空心箭头的实线表示；")]),_._v(" "),v("li",[_._v("学生与身份证之间为关联关系，使用一根实线表示；")]),_._v(" "),v("li",[_._v("学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；")])])])}),[],!1,null,null,null);v.default=t.exports}}]);